module jp.ac.jaist.kslab.sb.marte.merge.generator.MergeDslGeneratorMWE

import org.eclipse.emf.mwe.utils.*

var modelPath = "model"

var dslSlot = "dsl"
var specModel = "spec"
var circuitModel = "circuit"
var blockModel = "block"
var hardwareModel = "hrm"
var gatewayModel = "gateway"
var srmModel = "srm"
var umlModel = "uml"

var outputSlot = "output"

Workflow {
	
	bean = StandaloneSetup {
		scanClassPath = true
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwProtocol.HwProtocolPackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwSpecification.HwDatasheet.HwDatasheetPackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwLogical.HwDevice.HwDevicePackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwDiagram.HwDiagramPackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwSpecification.HwRegister.HwRegisterPackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwSpecification.HwPeripheral.HwPeripheralPackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.SRM.SW_Brokering.SW_BrokeringPackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwLogical.HwComputing.HwComputingPackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwSpecification.HwPackage.HwPackagePackage"
		registerGeneratedEPackage = "MARTE.MARTE_DesignModel.HRM.HwSpecification.HwDeviceFunction.HwDeviceFunctionPackage"
		registerGeneratedEPackage = "blockdiagram.BlockdiagramPackage"
	}


	// read spec DSLs.
	component = org.eclipse.xtext.mwe.Reader {
	// lookup all resources on the classpath
	// useJavaClassPath = true

	// or define search scope explicitly
		path = modelPath
		uriFilter = org.eclipse.xtext.mwe.NameBasedFilter{
			extension="spec"
		}

		// this class will be generated by the xtext generator
		register = jp.ac.jaist.kslab.sb.marte.spec.SpecDslStandaloneSetup{}
		loadResource = {
			slot = dslSlot
		}
	}
	// dsl to model trans
	component = DSLTransformer {
		input = dslSlot
		output = specModel
		modelSlot = ""
	}
	
	// read Circuit Model
	component = org.eclipse.xtext.mwe.Reader {
	// lookup all resources on the classpath
	// useJavaClassPath = true

	// or define search scope explicitly
		path = modelPath
		uriFilter = org.eclipse.xtext.mwe.NameBasedFilter{
			extension="circuit"
		}

		// this class will be generated by the xtext generator 
		register = jp.ac.jaist.kslab.sb.marte.dsl.circuit.CircuitDslStandaloneSetup {}
		loadResource = {
			slot = circuitModel
		}
	}

	// read Blockdiagram model
	component = Reader {
		uri = "model/motionlogger.blockdiagram"
		
		modelSlot = blockModel
	}
	
	// merge models
	component = HardwareModelMerger {
		spec = specModel
		circuit = circuitModel
		block = blockModel
		output = hardwareModel
	}
	
	
	component = HRMtoSRMTransformer{
		hardwareModel = hardwareModel
		gatewayModel = gatewayModel
	}
	
	component = SRMtoUMLTransformer{
		gatewayModel = gatewayModel
		umlModel = umlModel
	}
	
	component = ModelToResource{
		in = umlModel
		out = "out"
	}
	
	component = org.eclipse.xtext.generator.GeneratorComponent{
		slot = "out"
		register = jp.ac.jaist.kslab.sb.marte.merge.MergeDslStandaloneSetup{}
		outlet = {
			path = "output"
		}
	}
	
	// 
	// output models
	component = HardwareModelWriter {
		uri = "output/hardware.xmi"
		modelSlot = hardwareModel
	}
	component = HardwareModelWriter {
		uri = "output/gateway.xmi"
		modelSlot = gatewayModel
	}
	component = HardwareModelWriter {
		uri = "output/uml.xmi"
		modelSlot = umlModel
	}
/* 
	component = Writer {
		multipleResourcesInCaseOfList = true
		modelSlot = specModel
		uri = 'model/model.xmi'
	}*/
}
